ifndef::wd[]
:wd: pages
//:doctype: book
//:docinfo:
:toc: macro
:toclevels: 5
:toc-title: Содержание
:pagenums:
:chapter-label:
:imagesdir: ./
:source-highlighter: rouge

[[SOC_BOOT]]
= Процедура загрузки микросхемы
//include::../../../asciidoc_common/header.asciidoc[]
endif::[]

ifeval::["{wd}"=="pages"]
toc::[]
endif::[]

// generic, o32t
ifndef::soc[]
:soc: o32t
:boot_version: 300
:boot_has_v3_support: yes
//:boot_has_v2_support: yes
//:boot_has_v1_support: yes
endif::[]

== Общее описание алгоритма начальной загрузки микросхемы

include::soc/{soc}/soc_boot_description.asciidoc[]

== ПЗУ начальной загрузки (bootrom)

=== Общее описание работы начального загрузчика

Поведение первичного загрузчика определяется BOOTM выводами микросхемы. Значение выводов считывается однократно при сбросе микрсхемы (кроме сигнала SD Card Detect, значение которого проверяется при попытке загрузиться с SD карты). Общий алгоритм поведения загрузчика представлен на рисунке <<figure-rumboot-flow>>

В общем случае загрузчик работает в одном из двух режимов:

* Хост-режим - ожидание загрузки образа вторичного загрузчика в память по основному технологическому каналу, UART или вспомогательному технологическому каналу (см. <<rumboot-tech-channels>>) Этот режим используется для отладки и внутрисхемной прошивки готовых изделий.

* Нормальный режим - поиск образов вторичного загрузчика на внешних ПЗУ, загрузка во внутреннюю память и их исполнение. Это основной режим работы.

include::soc/{soc}/bootflow.asciidoc[]

Ключевыми для поведения загрузчика являются три конфигурационных вывода:

* _SELFTEST_: Вывод выбирает выполнять ли процедуру самотестирования при старте микросхемы. 0 - Не выполнять, 1 - выполнять.

* _HOST_: Вывод включает принудительную загрузку в Host-режиме . 0 - Не задействовать, 1 - задействовать. Подробнее см. (раздел Host-режим)

* _UART_SPEED_: Выводы, задающие скорость отладочного вывода при начальной загрузки.

Полный список конфигурационных выводов приведен в таблице <<tbl_sys_boot_cfg>>.

NOTE: В готовых изделиях рекомендуется сократить количество конфигурационных выводов до одного: HOST. HOST-режим предназначен для внутрисхемного программирования внешних микросхем памяти и потребуется в ходе процедуры начальной прошивки и тестирования изделий, обновления, либо восстановления микропрограммы устройства.

=== Процедура самотестирования микросхемы

include::soc/{soc}/selftest.asciidoc[]

=== Программная модель взаимодействия со встроенным ПЗУ

==== Введение

Начальный загрузчик имеет жестко заданную рабочую область памяти (SPL область, область вторичного загрузчика), служащую промежуточным буфером для всех операций с загружаемым образом вторичного загрузчика. 

. В хост-режиме загрузчик ожидает приглашения для загрузки данных по основному технологическому каналу (UART). Одновременно производится опрос SPL области на предмет наличия корректного образа вторичного загрузчика, который может быть загружен по вторичному технологическому каналу (см. <<rumboot-tech-channels>>)

. В нормальном режиме загрузки, начальный загрузчик ищет корректные образы вторичного загрузчика на внешних носителях в порядке приоритета (см. <<rumboot-boot-order>>). Перед валидацией, данные загружаются в SPL область и не могут превышать ее размер. В ПЗУ может располагаться более одного образа вторичного загрузчика для исполнения загрузки "цепочкой" (см. <<rumboot-chain-boot>>)

Образ вторичного загрузчика должен иметь служебный заголовок (см. <<rumboot-header-struct>>) Заголовок позволяет загрузчику провести проверку целостности данных образа вторичного загрузчика, базовую проверку совместимости загружаемого кода и СБИС. 

В качестве контрольных сумм используется реализация CRC-32-IEEE 802.3 с полиномом X32+X26+X23+X22+X16+X12+X11+X10+X8+X7+X5+X4+X2+X1+X^0.
В случае обнаружения ошибок при проведении проверки совместимости и целостности образа исходного кода вторичного загрузчика первичный ПЗУ-загрузчик выводит диагностическое сообщение в интерфейс UART0, а также переписывает первое 32-битное слово (поле magic заголовка) кодом обнаруженной ошибки. Список кодов ошибки приведен в таблице <<tbl_rumboot_error_codes>>.

Для обеспечения совместимости между различными СБИС производства ЗАО НТЦ "Модуль" и упрощения процесса переноса ПО между различными микросхемами, спецификации начального загрузчика являются общими между микросхемами и идентифицируются номерами версий. Для идентификации используется система из трех цифр (мажорная.минорная.номер_сборки)

. При изменении первого компонента (мажорной) версии может изменяться структура заголовка образа вторичного загрузчика и положение полей.

. При изменении минорной версии загрузчика, может добавляться новый функционал, исправляться ошибки, но положение полей заголовка и значение поля version останется прежним. 

. Номер сборки указывает номер полного регрессионного прогона, в ходе которого был сгенерирован код загрузчика.

Дополнительно в загрузчике сохраняется хэш коммита, из которого была проведена сборка. Эта информация выводится через отладочный интерфейс UART в самом начале работы микросхемы. Полный список существующих на данный момент версий загрузчика можно увидеть в Таблице <<tbl_rumboot_versions>>.

Существующие версии спецификации загрузчика и микросхемы с ним:

.Существующие версии загрузчика в составе разных СБИС
[#tbl_rumboot_versions,cols="10,45,45",options="header"]
|===
| Номер версии загрузчика
| Микросхемы с данной версией загрузчика
| Примечание

|1.0
|1888ТХ018
|Первая версия спецификации загрузчика. 

|2.0 
|1888ВС048
|Полностью переработан формат заголовка, другие изменения.

|2.1
|1888ВС058, 1888ВМ018(A), 1888ВМ01H4
|Относительно версии 2.0 имеет только небольшие исправления

|3.0
|1888ВМ028А
|Имеет обратную совместимость с заголовками формата второй версии. 
|===


ifdef::boot_has_v3_support[]
include::common/v3.asciidoc[]
endif::[]

ifdef::boot_has_v2_support[]
include::common/v2.asciidoc[]
endif::[]

ifdef::boot_has_v1_support[]
include::common/v1.asciidoc[]
endif::[]

[#rumboot-feat-decaps]
==== Поддержка декапсуляции образа вторичного загрузчика

В некоторых случаях у загружаемой программы (или данных) необходимо отбросить служебный заголовок. Начальный загрузчик начиная с третьей версии может это делать ориентируясь на значение флага DECAPS в поле flags заголовка. 
При наличие этого флага после завершения валидации, данные образа будут перемещены в самое начало. 

IMPORTANT: В этом режиме значение поля device заголовка не устанавливается и по нему нельзя определить с какого устройства была произведена загрузка.

[#rumboot-feat-relocate]
==== Поддержка релокации образа вторичного загрузчика

Начиная с версии 3 загрузчик поддерживает релокацию загружаемых программ по произвольным адресам в памяти. Для того, чтобы воспользоваться этой возможностью необходимо: 

. Установить флаг RELOCATE поля flags заголовка в 1

. Указать виртуальный адрес релокации в поле relocation заголовка

WARNING: Проверка целостности все равно выполняется в SPL области, потому размер данных и заголовка не могут превышать этот размер даже если программа будет исполняться из другой памяти.  

[#rumboot-feat-compress]
==== Поддержка сжатия данных образа вторичного загрузчика

При работе с низкоскоростными ПЗУ и загрузке по протоколу xmodem бывает полезно применять сжатие данных, что позволяет сократить время чтения данных из flash памяти. Начиная с третьей версии загрузчик поддерживает опциональное сжатие данных алгоритмом heatshrink2. 

.Параметры декомпрессора heatshrink в начальном загрузчике 
[#tbl_rumboot_heatshrink_params,cols="50,50",options="header"]
|===
|Параметр
|Значение

|HEATSHRINK_INPUT_BUFFER_SIZE 
|32

|HEATSHRINK_WINDOW_BITS 
|11

|HEATSHRINK_LOOKAHEAD_BITS 
|4
|===

Для того, чтобы использовать сжатие необходимо сжать секцию данных алгоритмом heatshrink2 с параметрами, указанными в Таблице <<tbl_rumboot_heatshrink_params>>. В поле flags заголовка необходимо установить бит COMPRESS.

Загрузчик поддерживает два режима декомпрессии:

. Декомпрессия без релокации. В этом режиме сжатые данные перед распаковкой перемещаются в конец SPL области, а распаковка производится в начальные адреса. В случае коллизии сжатых и несжатых данных будет пользователю в UART будет выведено сообщение об ошибке, а загрузка прервана. Точный максимальный размер загружаемых данных будет зависеть от уровня сжатия и структуры загружаемых данных.

//TODO: Сюда нужна иллюстрация

. Декомпрессия с релокацией. В этом режиме, когда установлен флаг RELOCATE (см. <<rumboot-relocate>>) данные распаковвываются напрямую в целевую область, указанную в поле RELOCATE. В этом режиме максимальный разммер сжатых данных не может превышать размер SPL области минус размер заголовка. 

Сжатие также учитывает наличие или отсутствие флага DECAPS.

==== Последовательное исполнение кода из нескольких источников

Первичный загрузчик поддерживает последовательное исполнение кода с одного или нескольких источников, в случае если после исполнения кода вторичного загрузчика был произведен возврат в код ROM с соответствующим кодом завершения.
После вызова загрузчиком и функции по адресу точки входа из вторичного загрузчика, дальнейшее поведение зависит от возвращаемого этой функцией значения:

. > 0 - Принудительная загрузка с источника номер N-1 (Если N больше количества доступных источников - переход в хост-режим).
. == 0 - Продолжить цепочку загрузки с этого (следующий образ) или следующего источника.
. == -1 - принудительный переход в хост-режим.
. < -1 - Продолжить цепочку загрузки со следующего источника.

==== Последовательное исполнение нескольких образов вторичного загрузчика

Несколько корректных образов вторичного загрузчика можно записать последовательно. В случае если после исполнения кода первого экземпляра вторичного загрузчика был возврат в rom с кодом 0, из этого же источника будет загружен следующий образ и (в случае успешного прохождения процедуры целостности) также исполнен.
Если устройство загрузки требует доступа с фиксированным размером блока, то следующий загружаемый образ должен находиться в начале следующего блока данных.
Пример: SD карта памяти. Размер блока 512 Б. Первый образ загружается со смещения 8192 Б и занимает 1467 Б (включая заголовок).
Как видно из выражения, (8192 + 1467) % 512 = 443, конец первого образа вторичного загрузчика не выровнен по границе блока. Таким образом, попытка загрузки следующего образа с данного устройства будет проводиться со смещения:
(8192 + 1467) + (512 - 443) = 9728


include::soc/{soc}/features.asciidoc[]

.Коды ошибок, записываемые в поле magic при неудачной загрузке
[#tbl_rumboot_error_codes,cols="10,10,90",options="header"]
|===
|Имя в коде загрузчика
|Код ошибки
|Описание

|-
|0
|Успешная загрузка, нет ошибок

|EBADMAGIC
|1
|Неправильное значение поле magic

|EBADVERSION
|2
|Несовпадение версии заголовка загрузчика

|EBADHDRCRC
|3
|Ошибка в контрольной сумме заголовка

|EBADCHIPID
|4
|Несовместимое значение поле chip id. Это образ от другой СБИС.

|EBADENTRY
|5
|Точка входа первичного ядра не прошла процедуру валидации (Из целевой памяти нельзя исполнять код!)

|EBADHEADER
|6
|Ошибка в заголовке. Все ошибки заголовка имеют код меньше этого числа

|EBADDATACRC
|7
|Ошибка при проверке контрольной суммы данных

|ETOOBIG
|8
|Размер данных превышает доступный для вторичного загрузчика размер встроенного ОЗУ. 

|EBADSOURCE
|9
|Ошибка источника. После завершения исполнения программы вторичного загрузчика был запрошен переход на невалидный/несуществующий источник загрузки

|EIO
|10
|Произошла ошибка ввода/вывода при чтении вторичного загрузчика из внешней памяти

|ETOHOST
|11
|Запрошен переход в host-режим (Используется в коде загрузчика)

|EBADCLUSTERID
|12
|В заголовке указано, что код предназначен для исполнения на целевом процессорном кластере, который отсутствует в данной системе.

|===

[#rumboot-tech-channels]
=== Вторичные технологические каналы

include::soc/{soc}/tech_channels.asciidoc[]

При загрузке в хост-режиме через вторичные технологические каналы, для исключения начала преждевременной процедуры проверки совместимости и целостности загружаемого образа исполняемого кода вторичного загрузчика, рекомендуется использовать следующую последовательность загрузки по образа по хост-интерфейсу:

. Загрузить SPL область весь образ, за исключением первых 4-х байт.

. Установить в ячейки памяти, соответсвующие первым 4-м байтам образа вторичного загрузчика, значение служебного слова 0xb01dface в соответствующем образу порядке байт.

[#rumboot-boot-order]
=== Приоритет загрузки с внешних микросхем памяти ПЗУ

include::soc/{soc}/boot_priority.asciidoc[]

//[#rumboot-cheat-sheet]
//=== Краткая справочная информация для разработчика ПО

=== Рекомендации по схемотехнике

==== Реализация автоматического сброса/подачи питания через диагностический разъем UART.

При использовании микросхем преобразователей USB-to-UART в составе изделия на базе данной микросхемы удобно реализовать процедуру автоматического сброса/снятия питания. Это позволяет автоматизировать процессы тестирования и упростить отладку программного обеспечения. 

Для этой задачи можно использовать выводы GPIO представленные на некоторых микросхемах преобразователей интерфейсов, такие как Prolific PL2303HXA или Silicon Labs CP2102 / CP2103.

Рекомендованное подключение линий указано в таблице <<tbl_pl2303>>. Пример схемы сброса приведен на Рис. 

.Рекомендованное подключение выводов сброса и управления питанием
[#tbl_pl2303,cols="10,10,10",options="header"]
|===
|Вывод PL2303HXA/HXD
|Вывод микросхемы
|Комментарий

|GP0|RESET| Active Low
|GP1|POWER| Active Low
|GP2|HOST | Для PL2303HXD/CP2102
|=== 

WARNING: Популярные миксрохемы FTDI FT232RL и подобные не подходят для этой задачи, так как не доспускают одновременную работу преобразователя USB-to-UART и управление выводами CBUS. Более того, на момент написания этого документа в продаже широко распространены контрафактные микросхемы FTDI в которых режим управления выводами CBUS не функционирует. 


.Пример схемы сброса СБИС
[#figure-reset-sch]
image::img/reset_pl2303.png[]
