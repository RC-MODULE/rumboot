==== Работа с заголовком третьей версии
===== Структура заголовка образа вторичного загрузчика

В начале файла образа вторичного загрузчика располагается служебная структура, приведенная на листинге <<rumboot-v3-header>>.

.Структура заголовка образа вторичного загрузчика 
[source#rumboot-v3-header,C]
----
struct rumboot_bootheader {
    uint32_t  magic;
    uint8_t   version;
    uint8_t   flags;
    uint8_t   chip_id;
    uint8_t   chip_rev;
    uint32_t  data_crc32;
    uint32_t  datalen;
    uint32_t  entry_point[2];
    uint64_t  relocation;
    uint8_t   target_cpu_cluster;
    uint8_t   reserved1;
    uint8_t   reserved2;
    uint8_t   reserved3;
    uint32_t  bootargs[5];
    uint32_t  header_crc32;
    uint32_t  device;
    char     data[];
} __attribute__((packed));
----

Назначение полей структуры приведены в Таблице <<tbl_rumboot_header_v3>>

.Назначение полей третьей версии структуры заголовка 
[#tbl_rumboot_header_v3,cols="10,90",options="header"]
|===
|Имя поля
|Назначение

|magic 
|Служебное слово (0xb01dface) в порядке байт целевой системы. Идентифицирует начало корректного заголовка. По порядку байт этого поля утилита для подготовки образов вторичного загрузчика определяет целевой порядок байтов для записи контрольной суммы. При отсутствии корректного ключевого слова образ не будет загружен. Дополнительно порядок байт этого слова может использоваться загрузчиком для исполнения кода в режиме переворота эндиантности см. <<rumboot-feat-endian-swap>>

|version 
| Версия заголовка (мажорная версия загрузчика). 3. В случае неправильного значения этого поля образ не пройдет валидацию загрузчиком и не будет исполнен.

|flags 
|Битовая маска из флагов, управляющих процессом загрузки. Подробнее см. <<tbl_rumboot_header_v3_flags>>

| chip_id  
|Идентификатор микросхемы. Если идентификатор не совпадает с ожидаемым для этой микросхемы, то образ считается невалидным и не будет исполнен. 

|chip_rev 
| Идентификатор ревизии микросхемы, если было выпущено более одной ревизии. При несовпадении с ожидаемым в журнал загрузки будет выведено предупреждение.

|data_crc32 
|CRC32 контрольная сумма для данных образа.

|datalen 
|Длина секции данных в байтах

|entry_point[2] 
|Адрес точки входа в виде массива из двух 32-битных чисел в порядке байт целевой программы. Первым числом идут младшие 32-бита, потом старшие. Для 32-битных процессорных ядер старшая часть не используется. Пример заполнения поля см. <<rumboot-v3-header-example>>

|relocation
|64-битный адрес релокации в порядке байт целевой программы. При наличии соответствующего флага в поле flags образ будет перемещен по указанному адресу перед исполнением. Для 32-битных систем используются только младшие 32 бита.

|header_crc32 
|CRC32 контрольная сумма всех полей заголовка, идущих до данного поля.

|target_cpu_cluster
|Целевой процессорный кластер. Загрузчик предоставляет возможность запускать код на вторичных процессорных ядрах. Если код предназначен для другого ядра, то его номер нужно указать в этом поле.

|reserved1 
| Поле зарезервировано для дальнейшего использования
|reserved2 
| Поле зарезервировано для дальнейшего использования
|reserved3 
| Поле зарезервировано для дальнейшего использования

| bootargs[5]
| Аргументы, которые будут переданы загружаемой программы согласно ABI.

|device 
|Ячейка памяти, резервируемая в образе первчиного загрузчика. В случае успешной загрузки во внутреннюю SRAM память и успешную валидацию образа, сюда будет записан указатель на структуру устройства, с которого была выполнена загрузка. В случае загрузки в хост-режиме, в это поле будет записан NULL. В дальнейшем, поля структуры bootsource можно использовать для считывания дополнительных данных с устройства, откуда была произведена загрузка. Исключается из проверки контрольными суммами.

|===


.Значение битов поля flags заголовка вторичного загрузчика
[#tbl_rumboot_header_v3_flags,cols="10,10,80",options="header"]
|===
|Номер бита
|Имя флага
|Назначение

|0
|COMPRESS
|Если этот бит установлен (1), это сигнализирует о том, что данные после заголовка сжаты алгоритмом heatshrink. Загрузчик произведет декомпрессию данных перед исполнением. см. <<rumboot-feat-compress>> 

|1
|DATA
|Если этот бит установлен, то образ содержит только данные. Их надо разместить в памяти, но не выполнять переход на точку входа. После размещения данных загрузчик перейдет к следующему образу вторичного загрузчика. 

|2
|RESERVED
|Этот бит зарезервирован для дальнейших применений

|3
|SMP
|Если этот бит установлен, то на многоядерной SMP системе, все процессорные ядра целевого процессорного кластера начнут исполнение с точки входа одновременно. На не-SMP системах этот бит не имеет значения.

|4
|DECAPS
|Если этот бит установлен, то необходимо выполнить декапсуляцию - удаление заголовка перед исполнением кода. Это может быть нужно для некоторых вспомогательных процессорных ядер (NeuroMatrix), у которых в самом начале внутренней памяти всегда располагается таблица векторов прерываний. см. <<rumboot-feat-decaps>>

|5
|RELOCATE
|Если этот флаг установлен, то необходимо разместить данные по адресу, указанному в поле relocation заголовка. см. <<rumboot-feat-relocate>>

|6
|SYNC
|Этот бит влияет на поведение кода, исполняемого на вторичных процессорных ядрах. Если этот флаг установлен, то исполнение будет синхронным: основное процессорное ядро будет ожидать завершения работы программы и перенаправлять вывод в UART0. Без этого флага исполнение будет асинхронным: основное процессорное ядро начнет исполнение кода на вторичном ядре и перейдет к загрузке следующего образа.

|7
|KILL
|Если этот бит установлен, то вторичное процессорное ядро получит сигнал о принудительном завершении работающей программы.
|===

===== Добавление заголовка загрузчика третьей версии к прикладным программам

Добавлять корректный заголовок к образу загрузчика предлагается в два этапа:

. На этапе компиляции объявлять структуру заголовка и заполнять поле точки входа, поля известные на этапе компиляции (magic, version, chip_id, chip_rev, точку входа и т.п.). Структуру позиционировать в начале файла используя сценарий линковки. см. <<rumboot-v3-header-example>> и <<rumboot-v3-lds-example>>.
. После компиляции и формирования бинарного файла добавлять в существующий заголовок контрольные суммы внешней программой, т.к. они не известны на этапе компиляции.

.Пример объявления структуры заголовка в программе
[source#rumboot-v3-header-example,C]
----
static const __attribute__((used)) __attribute__((section(".header")))
struct rumboot_bootheader hdr  = {
	.magic		= 0xb01dface,
	.version	= 3,
	.chip_id	= 7,
	.chip_rev	= 2,
	.entry_point	= { (uint32_t) &main, 0x0 },
	.target_cpu_cluster = RUMBOOT_TARGET_CPU_CLUSTER,
};
----

.Упрощенный пример сценария линковки для gcc
[source#rumboot-v3-lds-example,lds]
----

SECTIONS {
    .rwx : {
        rumboot_self = .;
        KEEP(*(.header))
        /* ROM sections copy */
        *(.text.irq)
        *(*.init.text)
        /* ROM sections copy end */

        *(.text)
        *(.text.*)
        *(.rodata)
        *(.rodata.*)
        *(.data)
        *(.data.*)
        *(.sdata)
        *(.sdata.*)
        *(.sdata2)
        *(.sdata2.*)

        rumboot_platform_bss_start = .;
        *(.bss)
        *(.bss.*)
        *(.sbss)
        *(.sbss.*)
        *(COMMON)
        rumboot_platform_bss_end = .;

    } > INTERNAL_MEMORY

}
----

Для процессорных ядер, имеющих жестко заданную таблицу векторов прерываний в начальных адресах (Таких, как Neuromatrix RISC, Neuromatrix) сценарий линковки будет отличаться, необходимо использовать директиву OVERLAY.
Пример приведен на листинге <<rumboot-v3-lds-example-nmc>>. Дополнительно такие программы необходимо загружать с флагом DECAPS, чтобы удалить служебный заголовок после его валидации.

.Упрощенный пример сценария линковки для nmc-gcc
[source#rumboot-v3-lds-example-nmc,lds]
----
OUTPUT_FORMAT("elf32-nmc", "elf32-nmc", "elf32-nmc")
OUTPUT_ARCH(nmc)

MEMORY
{
  IM1(rwx):       ORIGIN =  0x00000, LENGTH = 0x20000
  IM2(rwx):       ORIGIN =  0x20000, LENGTH = 0x20000
  IM3(rwx):       ORIGIN =  0x40000, LENGTH = 0x20000
  SRAM(rwx):      ORIGIN =  0x100000000, LENGTH  = 0x100000
}

SECTIONS
{
  OVERLAY : {
    .header {
      KEEP(*(.header))
    }
    .init {
      KEEP(*(.text.init))
    }    
  } > IM1

  .rwx : {
   *(.text)
   *(.text.*)
   *(.rodata)
   *(.rodata.*)
   *(.data)
   *(.data.*)
  } > IM1

  .bss : {
    rumboot_platform_spl_start = .;
    rumboot_platform_spl_end = .;
    _rumboot_platform_bss_start = .;
    *(.bss)
    *(.bss.*)
    *(.bsst)
    *(.bsst.*)
    *(COMMON)
    _rumboot_platform_bss_end = .;
  } > IM1

}

----

===== Передача аргументов загружаемой программе
Точка входа в образ вторичного загрузчика имеет следующий формат:

[source,C]
----
int (*main)(uint32_t a, uint32_t b, uint32_t c, uint32_t d, uint32_t e); 
----

Переход на точку входа выполняется как вызов функции, а не безусловный переход. Это позволяет после исполнения кода вторичного загрузчика вернуться в ROM, загрузить следующий бинарный файл или провести загрузку с другого источника на основе анализа кода возврата. 

Значение полей заголовка bootargs помещается в регистры согласно ABI, что позволяет передать аргументы загружаемой программе (Например, адреса расположения данных).
