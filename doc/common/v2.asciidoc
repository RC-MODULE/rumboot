ifdef::boot_has_v3_support[]
==== Работа с заголовком второй версии (режим обратной совместимости) 
Для обеспечения обратной совместимости, начальный загрузчик поддерживает также загрузку образов с заголовком предыдущей (второй) версии спецификации. При отсутствии необходимости, рекомендуется использовать формат заголовка третьей версии.
else::[]
==== Работа с заголовком второй версии
endif::[]
===== Структура заголовка образа вторичного загрузчика

В начале файла образа вторичного загрузчика располагается служебная структура, приведенная на листинге <<rumboot-v2-header>>.

.Структура заголовка образа вторичного загрузчика 
[source#rumboot-v2-header,C]
----
struct __attribute__((packed)) rumboot_bootheader_v2 {
    uint32_t magic;
    uint8_t  version;
    uint8_t  reserved;
    uint8_t  chip_id;
    uint8_t  chip_rev;
    uint32_t data_crc32;
    uint32_t datalen;
    uint32_t entry_point[10];
    uint32_t header_crc32;
    const struct rumboot_bootsource *device;
    char     data[];
};
----

Назначение полей структуры приведены в Таблице <<tbl_rumboot_header_v2>>

.Назначение полей второй версии структуры заголовка 
[#tbl_rumboot_header_v2,cols="10,90",options="header"]
|===
|Имя поля
|Назначение

|magic 
|Служебное слово (0xb01dface) в порядке байт целевой системы. Идентифицирует начало корректного заголовка. По порядку байт этого поля утилита для подготовки образов вторичного загрузчика определяет целевой порядок байтов для записи контрольной суммы. При отсутствии корректного ключевого слова образ не будет загружен. Дополнительно порядок байт этого слова может использоваться загрузчиком для исполнения кода в режиме переворота эндиантности см. <<rumboot-feat-endian-swap>>

|version 
| Версия заголовка (мажорная версия загрузчика). 3. В случае неправильного значения этого поля образ не пройдет валидацию загрузчиком и не будет исполнен.

|reserved 
|Зарезервировано для следующих версих. Должно быть в 0.

| chip_id  
|Идентификатор микросхемы. Если идентификатор не совпадает с ожидаемым для этой микросхемы, то образ считается невалидным и не будет исполнен. 

|chip_rev 
| Идентификатор ревизии микросхемы, если было выпущено более одной ревизии. При несовпадении с ожидаемым в журнал загрузки будет выведено предупреждение.

|data_crc32 
|CRC32 контрольная сумма для данных образа.

|datalen 
|Длина секции данных в байтах

|entry_point[10] 
|Заголовком предусмотрено до 10 точек входа. Реально используются только нулевой элемент. Максимальное количество точек входа выбрано для выравнивания размера заголовка до размера в 64 Б. Адрес точки входа должен быть доступен в TLB, или будет считаться невалидным. В случае, если валидация точки входа вторичного загрузчика не проходит успешно, выводится предупреждение, образ считается некорректным.

|header_crc32 
|CRC32 контрольная сумма всех полей заголовка, идущих до данного поля.

|device 
|Ячейка памяти, резервируемая в образе первчиного загрузчика. В случае успешной загрузки во внутреннюю SRAM память и успешную валидацию образа, сюда будет записан указатель на структуру устройства, с которого была выполнена загрузка. В случае загрузки в хост-режиме, в это поле будет записан NULL. В дальнейшем, поля структуры bootsource можно использовать для считывания дополнительных данных с устройства, откуда была произведена загрузка. Исключается из проверки контрольными суммами.

|===


===== Добавление заголовка загрузчика второй версии к прикладным программам

Добавлять корректный заголовок к образу загрузчика предлагается в два этапа:

. На этапе компиляции объявлять структуру заголовка и заполнять поле точки входа, поля известные на этапе компиляции (magic, version, chip_id, chip_rev, точку входа и т.п.). Структуру позиционировать в начале файла используя сценарий линковки. см. <<rumboot-v2-header-example>> и <<rumboot-v2-lds-example>>.
. После компиляции и формирования бинарного файла добавлять в существующий заголовок контрольные суммы внешней программой, т.к. они не известны на этапе компиляции.

.Пример объявления структуры заголовка в программе
[source#rumboot-v3-header-example,C]
----
static const __attribute__((used)) __attribute__((section(".header")))
struct rumboot_bootheader hdr  = {
	.magic		    = 0xb01dface,
	.version	    = 3,
	.chip_id	    = 7,
	.chip_rev	    = 2,
	.entry_point	= &main,
};
----

.Упрощенный пример сценария линковки для gcc
[source#rumboot-v2-lds-example,lds]
----

SECTIONS {
    .rwx : {
        rumboot_self = .;
        KEEP(*(.header))
        /* ROM sections copy */
        *(.text.irq)
        *(*.init.text)
        /* ROM sections copy end */

        *(.text)
        *(.text.*)
        *(.rodata)
        *(.rodata.*)
        *(.data)
        *(.data.*)
        *(.sdata)
        *(.sdata.*)
        *(.sdata2)
        *(.sdata2.*)

        rumboot_platform_bss_start = .;
        *(.bss)
        *(.bss.*)
        *(.sbss)
        *(.sbss.*)
        *(COMMON)
        rumboot_platform_bss_end = .;

    } > INTERNAL_MEMORY

}
----

===== Передача аргументов загружаемой программе
Точка входа в образ вторичного загрузчика имеет следующий формат:

[source,C]
----
int (*main)(); 
----

Переход на точку входа выполняется как вызов функции, а не безусловный переход. Это позволяет после исполнения кода вторичного загрузчика вернуться в ROM, загрузить следующий бинарный файл или провести загрузку с другого источника на основе анализа кода возврата. 
