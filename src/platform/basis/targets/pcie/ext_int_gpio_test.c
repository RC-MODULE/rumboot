
//-----------------------------------------------------------------------------
//  This program is for PCIe EXT_IRQ_GEN External interruptions testing
//    Interruptions are generated by incorrect writes to Address Translator
//    EXT_IRQ pin_out is connected to GPIO2_0 pin_in
//    Test includes:
//    - setting EXT_IRQ_GEN
//    - setting Address Translator
//    - repeat few times:
//      - clear interruption effects
//      - check GPIO2_0 low
//      - generating interruptions with incorrect AXI writes to AT
//      - wait some time
//      - check GPIO2_0 high
//    - 
//    
//    Test duration (RTL): < 250us
//-----------------------------------------------------------------------------

#include <stdint.h>
#include <rumboot/io.h>
#include <platform/devices.h>
#include <regs/regs_pcie.h>
#include <regs/regs_gpio.h>

#include <rumboot/pcie_test_lib.h>

#define interrupt_turnaround_duration 1
#define interrupt_repeat_number 16

//------------------------------------------------------------------------
//  Send AXI transaction to Address Translator, missing all regions
//  That will cause interruption, that will create MSIX transasction
//  Data have no meaning
//  Address must miss all regions (correspond addr_trans_slv_config)
//------------------------------------------------------------------------
void create_error_transaction ()
{
    *(volatile uint32_t*) (0x7FFFF000) = 0x12345678;
}

//------------------------------------------------------------------------
//  Clear all interruption effects:
//    - status in ADDR_TRANS_SLV
//    - status in EXT_IRQ_GEN
//  
//  Usefull for repeating interruptions and repeating program
//------------------------------------------------------------------------
void clear_external_int_status ()
{
    uint32_t rdata;
    
    rdata = ioread32 (ADDR_TRANS_SLV_BASE + ADDR_TRANS_SLV_ctrl) | 0x1;
    iowrite32 (rdata, ADDR_TRANS_SLV_BASE + ADDR_TRANS_SLV_ctrl);
    iowrite32 (0x20000000, EXT_IRQ_GEN_BASE + EXT_IRQ_GEN_Global_IRQ_Status_l);
}

uint32_t check_gpio2_0_low ()
{
    if ((ioread32 (GPIO2_BASE + GPIO_READ_PADtoAPB) & 0x1) != 0x0)
        return -1;
    return 0;
}

uint32_t check_gpio2_0_high ()
{
    if ((ioread32 (GPIO2_BASE + GPIO_READ_PADtoAPB) & 0x1) != 0x1)
        return -1;
    return 0;
}

uint32_t main ()
{
    // if (pcie_turn_on_with_options_ep (1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) != 0)
        // return -1;
    // ext_irq_gen_config (0x1, 0x00000000, 0x00000003);
    
    //-------------------------------------------------------------------------
    //  Not very sure
    iowrite32 (0x1       , EXT_IRQ_GEN_BASE + EXT_IRQ_GEN_Ctrl             );
    iowrite32 (0x00000000, EXT_IRQ_GEN_BASE + EXT_IRQ_GEN_Global_IRQ_Mask_h);
    iowrite32 (0x00000003, EXT_IRQ_GEN_BASE + EXT_IRQ_GEN_Global_IRQ_Mask_l);
    
    volatile uint32_t* addr_pointer = (uint32_t*) (EXT_IRQ_GEN_BASE + EXT_IRQ_GEN_v0_Message_Address);
    for (int i = 0; i < 64; i++)
    {
        *addr_pointer = 0x40050000 + (i << 2);
        addr_pointer+=2;
        *addr_pointer = i;
        addr_pointer++;
        *addr_pointer = 0;
        addr_pointer++;
    }
    //-------------------------------------------------------------------------
    
    addr_trans_slv_config (2);
    
    for (volatile uint32_t j = 0; j < interrupt_repeat_number; j++)
    {
        clear_external_int_status ();
        
        for (volatile uint32_t i = 0; i < interrupt_turnaround_duration; i++)
            ;
        if (check_gpio2_0_low () != 0)
            return -1;
        
        create_error_transaction ();
        
        for (volatile uint32_t i = 0; i < interrupt_turnaround_duration; i++)
            ;
        if (check_gpio2_0_high () != 0)
            return -1;
    }
    
    return 0;
}
