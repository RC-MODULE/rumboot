RumBoot - универсальный расширяемый загрузчик для СБИС СнК.

# Общая информация

- Поддержка big и little endian систем
- Не задействует прерывания
- Расширенная диагностика через последовательный порт
- Модульная архитектура

# Руководство пользователя

Эта часть документа содержит общую информацию о том, как работать с загрузчиком RumBoot.

## Процесс загрузки

### Последовательность загрузки

Диаграмма, описывающая процесс загрузки приведена на рисунке ниже.

<div style="page-break-after: always;"></div>
![Flow](img/rumboot_flow.png)

### Выводы микросхемы настраивающие последовательность загрузки

Поведение загрузчика определяется bootstrap выводами микросхемы. Значение выводов считывается в самом начале загрузки. В общем случае загрузчик использует три bootstrap вывода.

- **Selftest** Вывод выбирает выполнять ли процедуру самотестирования при старте микросхемы. 0 - Не задействовать, 1 - задействовать.

- **Host** Вывод включает принудительную загрузку в Host-режиме . 0 - Не задействовать, 1 - задействовать. Подробнее см. (раздел Host-режим)

- **Uart Speed** Выбор начальной скорости последовательного порта, используемого для вывода отладочных сообщений. 0 - 115200, 1 - максимально возможная скорость (зависит от СБИС).

Возможно добавление других выводов, специфичных для конкретной микросхемы. Точные номера выводов, настраивающие режимы, а так же использующиеся для сигналов SDIO Card Detect и SPI Chip Select приведены в документации на соответствующую микросхему.

При старте, загрузчик выводит в последовательный порт диагностическую информацию, в т.ч.  

## Приоритет выбора устройств для загрузки

Приоритет выбора устройств для загрузки определяется на этапе компиляции ROM загрузчика и специфичен для проекта СБИС.

Общий список доступных плагинов для источников загрузки приведен в таблице ниже.

Плагин                | Где используется       | Состояние
--------------------- | ---------------------- | ---------
SPI Flash (PL022 SPI) | basis, oi10            | Готов
SDIO                  | basis, mpw-proto, oi10 | WiP
I2C (RCM) EEPROM      | basis                  | WiP
NOR                   | oi10                   | TODO
file                  | native                 | TODO

Общие принципы, по которым составляется список загрузки СБИС.

- Устройства со сменными носителями (напр. SD карта), имеют больший приоритет при загрузке. Таким образом исключается ситуация, когда прошивка несъемного накопителя (например, spi flash, nor) приводит к неработоспособности системы и для восстановления функциональности платы требуется использование специальных средств (jtag, edcltool, etc.), которые могут быть в данный момент недоступны или демонтаж накопителя для перепрошивки через программатор.

- Перед попыткой использовать устройство для загрузки, всегда проводится максимально быстрая попытка проверки наличия накопителя. Для SD карты - проверка сигнала Card Detect через GPIO, для I2C EEPROM - проверка начального состояния линий SDA/SCL (должны быть в 1).

- При наличии специальных требований по времени загрузки с определенных накопителей, они могут быть перенесены в самое начало списка.

## Структура заголовка образов вторичного загрузчика

Образ вторичного загрузчика снабжается служебным заголовком, приведенным на Листинге ниже. Заголовок позволяет загрузчику провести проверку целостности данных образа вторичного загрузчика и базовую проверку совместимости образа и СБИС.

```c
struct __attribute__((packed)) rumboot_bootheader {
    uint32_t magic;
    uint8_t  version;
    uint8_t  num_cores;
    uint8_t  chip_id;
    uint8_t  chip_rev;
    uint32_t data_crc32;
    uint32_t datalen;
    uint32_t entry_point[11];
    uint32_t header_crc32;
    const struct rumboot_bootsource *device;
    char     data[];
};
```

Ниже приведено детальное описание полей заголовка образа

- **magic** - служебное слово (0xb01dface), идентифицирующее начало корректного заголовка. По порядку байт этого поля утилита для подготовки образов вторичного загрузчика определяет целевой порядок байт. Отсутствие корректного ключевого слова вызывает

- **version** - Версия заголовка. На данный момент 2\. В случае неправильного значения этого поля версия образ не будет исполнен.

- **num_cores** - количество процессорных ядер в данной СБИС. Определяет количество используемых точек входа (максимум - 11). Должно совпадать с количеством процессорных ядер в данной СБИС, иначе образ считается невалидным.

- **chip_id** - Идентификатор микросхемы (порядковый номер). Если идентификатор не совпадает, то образ считается невалидным и не будет исполнен. Таблица идентификаторов приведена в Приложении А

- **chip_rev** - Идентификатор ревизии микросхемы, если выпущено более одной ревизии. Начинается с 1\. Несовпадение номера ревизии с ожидаемым вызывает предупреждение в журнале в загрузки.

- **data_crc32** - CRC32 контрольная сумма для данных образа

- **datalen** - Длина данных в байтах

- **entry_point[11]** - До 11 точек входа. Реально используются только первые N. Максимальное количетсво выбрано для выравнивания заголовка по размеру в 64 байта. Нулевая точка входа всегда используется для первичного ядра. Каждая точка входа может проходить специфичную для данной СБИС валидацию перед использованием (Напр. доступность этого адреса в TLB для PowerPC). В случае если валидация проваливается образ считается некорректным и не будет исполнен.

- **header_crc32** - CRC32 контрольная сумма всех полей заголовка идущих до данного поля.

- **struct rumboot_bootsource *device** - ячейка резервируется в образе и исключается из проверки контрольными суммами. В случае успешной загрузки сюда записывается адрес в памяти на структуру устройства, с которого была выполнена загрузка. В случае загрузки с host'а в этом поле будет NULL. В дальнейшем поля структуры bootsource можно использовать в виде API для считывания дополнительных данных с устройства, откуда была произведена загрузка.

## Процедура формирования образов вторичного загрузчика

Образ вторичного загрузчика формируется в три стадии.

- На этапе компиляции заголовок образа определяется со всеми полями, кроме контрльных сумм и помещается в виде структуры в отдельную секцию.

Пример bootheader.c, который должен быть частью проекта вторичного загрузчика.

```c
#include <stdint.h>
#include <rumboot/boot.h>
#include <rumboot/platform.h>

extern void rumboot_main();
extern int main();

static const __attribute__((used)) __attribute__((section(".header")))
struct rumboot_bootheader hdr = {
    .magic        = RUMBOOT_HEADER_MAGIC,
    .version    = RUMBOOT_HEADER_VERSION,
    .num_cores    = RUMBOOT_PLATFORM_NUMCORES,
    .chip_id    = RUMBOOT_PLATFORM_CHIPID,
    .chip_rev    = RUMBOOT_PLATFORM_CHIPREV,
    .entry_point    = {
        (uint32_t)&main,
    }
};
```

- На этапе компоновки сценарий компановщика размещает секцию с заголовком в самом начале файла. Пример минимального ld сценария приведен ниже.

```lds
OUTPUT_ARCH(ARM)
MEMORY
{
    IM0 (rwx): ORIGIN = 0x40000, LENGTH = 0x40000
}

SECTIONS
{

 .header : {
   KEEP(*(.header))
 } > IM0

 .rwx : {
  *(.text)
  *(.text.*)
  *(.rodata)
  *(.data)
  } > IM0

}
```

- После компиляции утилита rumboot-packimage.py производит расчет и запись контрольных сумм в заголовок образа. Пример работы данной утилиты приведен ниже.

```
rumboot_packimage.py -f rumboot-basis-Debug-spl.bin -c
Wrote valid checksums to image header
=== RumBootV2 Header Information ===
Endianess:              little
Magic:                  0xb01dface
Header Version:         0x2
CPU Cores:              0x1
Chip ID:                0x3
Chip Revision:          0x1
Data Length:            380
Header CRC32:           0x7e2fc690 [Valid]
Data CRC32:             0x7824b25a [Valid]
```

## Использование указателя bootsrc для чтения дополнительных данных с загрузочного устройства из вторичного загрузчика

TODO: Примеры кода

## Получение служебной информации о версии RumBoot, СhipId/ChipRevision из вторичного загрузчика

TODO: Примеры кода

## Получение результатов процедуры самотестирования из вторичного загрузчика

TODO: Примеры кода

## Последовательное исполнение кода из нескольких источников

RumBoot поддерживает последовательное исполнение кода из нескольких источников, в случае если после исполнения кода вторичного загрузчика был произведен возврат в код ROM с кодом завершения.

Точка входа в образ вторичного загрузчика имеет следующий формат:

```
int main();
```

После вызова загрузчиком и исполения этой функции, дальнейшее поведение зависит от возвращаемого этой функцией значения.

- \>= 0 - Принудительная загрузка с источника номер N (Если N больше количества доступных источников - переход в хост-режим)

- -1 - продолжить цепочку загрузки

- <-1 - принудительный переход в хост-режим

## Хост-режим загрузки

Хост-режим - это специальный режим загрузки, который предназначен для обновления ПО.

В этом режиме загружаемый образ вторичного загрузчика может
быть размещен в накристальной памяти используя пассивный или активный метод.

К пассивным относится загрузка по интерфейсам JTAG, EDCL или Spacewire RMAP (если присутствуют). Загрузка по этим интерфейсам не требует конфигурации и загрузчик просто опрашивает периодически соответствующую область памяти.

К активному режиму относится загрузка по протоколу xmodem поверх UART или любому другому, который требует соответствующей реализации в составе bootrom.

Плагины, обеспечивающие загрузку в активном режиме можно выбирать на этапе компиляции загрузчика.

Плагин                  | Проект      | Статус
----------------------- | ----------- | -----------
xmodem (UART)           | basis, oi10 | планируется
командная строка (UART) | basis, oi10 | планируется

В host режиме, при успешной загрузке поле bootsrc устанавливается в NULL.

В случае ошибки при валидации загружаемого образа загрузчик выводит диагностическое сообщение в UART, а так же переписывает поле magic кодом ошибки. Список возможных ошибок приведен ниже.

```
#define EBADMAGIC      1
#define EBADVERSION    2
#define EBADHDRCRC     3
#define EBADCHIPID     4
#define EBADENTRY      5
#define EBADNUMCORES   6
#define EBADDATACRC    7
#define EMAXERROR      8
```

При загрузке по интерфейсу edcl/rmap/jtag для избежания преждевременной попытки валидации образа рекомендуется:

- Загрузить данные, начиная с 4го байта и до конца образа
- Установить magic (первые 4 байта) в валидное значение


# Приложение А: Таблица идентификаторов ChipID

ОКР   | Part Number | Endianess | #Cores | ChipID | ChipRev
----- | ----------- | --------- | ------ | ------ | -------
7705* | ???         | big       | 2      | 1      | 1
7705* | 1888ТХ018   | big       | 2      | 2      | 2
Базис | ???         | little    | 1      | 3      | 1
ОИ-10 | ???         | big       | 1      | 4      | 1

* Используют другой формат образа. Указанные ChipID/ChipRev используются только для прототипирования.


# Приложение В: Старые форматы образов загрузчика

TBD
