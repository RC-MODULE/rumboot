RumBoot - универсальный расширяемый загрузчик для СБИС СнК.

# Общая информация

- Поддержка big и little endian систем
- Не задействует прерывания
- Расширенная диагностика через последовательный порт
- Модульная архитектура

# Руководство пользователя

Эта часть документа содержит общую информацию о том, как работать с загрузчиком RumBoot.

## Процесс загрузки

### Выводы микросхемы настраивающие последовательность загрузки

Поведение загрузчика определяется bootstrap выводами микросхемы. Значение выводов считывается в самом начале загрузки. В общем случае загрузчик использует три bootstrap вывода, которое в случае необходимости можно сократить до одного (host mode):

- **Selftest** Вывод выбирает выполнять ли процедуру самотестирования при старте микросхемы. 0 - Не выполнять, 1 - выполнять.

- **Host** Вывод включает принудительную загрузку в Host-режиме . 0 - Не задействовать, 1 - задействовать. Подробнее см. (раздел Host-режим)

- **Uart Speed** Выбор начальной скорости последовательного порта, используемого для вывода отладочных сообщений. 0 - 115200, 1 - максимально возможная скорость (зависит от СБИС).

Возможно добавление других выводов, специфичных для конкретной микросхемы. Точные номера выводов, настраивающие режимы, а так же использующиеся для сигналов SDIO Card Detect и SPI Chip Select приведены в документации на соответствующую микросхему.

При старте, загрузчик выводит в последовательный порт диагностическую информацию, в т.ч.  git ревизию, из которой производилась сборка, тип сборки (Debug/Production), кодовое имя платформы и декодированные значения bootstrap выводов.   

Пример:

```
    RC Module's          __                __
   _______  ______ ___  / /_  ____  ____  / /_
  / ___/ / / / __ `__ \/ __ \/ __ \/ __ \/ __/
 / /  / /_/ / / / / / / /_/ / /_/ / /_/ / /_  
/_/   \__,_/_/ /_/ /_/_.___/\____/\____/\__/  
basis | Debug | master-60e4021
--- RumBoot Configuration ---
Force Host Mode: disabled
Selftest:        disabled
UART speed:      115200 bps
---          ---          ---
```

### Последовательность загрузки

Диаграмма, описывающая схематично процесс загрузки приведена на рисунке ниже.
Детальное описание отдельных этапов будет приведено далее по тексту.  

<div style="page-break-after: always;"></div>
![Flow](img/rumboot_flow.png)

## Приоритет выбора устройств для загрузки

Приоритет выбора устройств для загрузки определяется на этапе компиляции ROM загрузчика и специфичен для проекта СБИС.

Общий список доступных плагинов для источников загрузки и их статус приведен в таблице ниже.

Плагин                | Где используется       | Состояние
--------------------- | ---------------------- | ---------
SPI Flash (PL022 SPI) | basis, oi10            | Готов
SDIO                  | basis, mpw-proto, oi10 | WiP
I2C (RCM) EEPROM      | basis                  | WiP
NOR                   | oi10                   | TODO
file                  | native                 | TODO

Общие принципы, по которым составляется список загрузки СБИС.

- Устройства со сменными носителями (напр. SD карта), имеют больший приоритет при загрузке. Таким образом исключается ситуация, когда прошивка несъемного накопителя (например, spi flash, nor) приводит к неработоспособности системы и для восстановления функциональности платы требуется использование специальных средств (jtag, edcltool, etc.), которые могут быть в данный момент недоступны или демонтаж накопителя для перепрошивки через программатор.

- Перед попыткой использовать устройство для загрузки, всегда проводится максимально быстрая попытка проверки наличия накопителя. Для SD карты - проверка сигнала Card Detect через GPIO, для I2C EEPROM - проверка начального состояния линий SDA/SCL (должны быть в 1).

- При наличии специальных требований по времени загрузки с определенных накопителей, они могут быть перенесены в самое начало списка.

## Структура заголовка образов вторичного загрузчика

Образ вторичного загрузчика снабжается служебным заголовком, приведенным на Листинге ниже. Заголовок позволяет загрузчику провести проверку целостности данных образа вторичного загрузчика и базовую проверку совместимости образа и СБИС. Текущая версия заголовка (2) расчитана для 32х-битных систем, потому
для всех указателей используются поля по 32 бита.

```c
struct __attribute__((packed)) rumboot_bootheader {
    uint32_t magic;
    uint8_t  version;
    uint8_t  chip_id;
    uint8_t  reserved;
    uint8_t  chip_rev;
    uint32_t data_crc32;
    uint32_t datalen;
    uint32_t entry_point[10];
    uint32_t header_crc32;
    const struct rumboot_bootsource *device;
    char     data[];
};
```

Ниже приведено детальное описание полей заголовка образа

- **magic** - служебное слово (0xb01dface), идентифицирующее начало корректного заголовка. По порядку байт этого поля утилита для подготовки образов вторичного загрузчика определяет целевой порядок байт. При отсутствии корректного ключевого слова образ не будет загружен.  

- **version** - Версия заголовка. На данный момент 2. В случае неправильного значения этого поля образ не пройдет валидацию загрузчиком.

- **reserved** - Поле зарезервиновано.

- **chip_id** - Идентификатор микросхемы (порядковый номер). Если идентификатор не совпадает, то образ считается невалидным и не будет исполнен. Текущая таблица идентификаторов приведена в Приложении А.

- **chip_rev** - Идентификатор ревизии микросхемы, если выпущено более одной ревизии. Начинается с 1. Несовпадение номера ревизии с ожидаемым вызывает предупреждение в журнале в загрузки.

- **data_crc32** - CRC32 контрольная сумма для данных образа. Подробная информация об алгоритме будет приведена далее.

- **datalen** - Длина данных в байтах

- **entry_point[10]** - До 10 точек входа. Реально используются только первые N. Максимальное количетсво выбрано для выравнивания заголовка по размеру в 64 байта. Нулевая точка входа всегда используется для первичного ядра. Каждая точка входа может проходить специфичную для данной СБИС валидацию перед использованием (Напр. доступность этого адреса в TLB для PowerPC). В случае если валидация проваливается образ считается некорректным и не будет исполнен.

- **header_crc32** - CRC32 контрольная сумма всех полей заголовка идущих до данного поля.

- **struct rumboot_bootsource *device** - ячейка резервируется в образе и исключается из проверки контрольными суммами. В случае успешной загрузки сюда записывается адрес в памяти на структуру устройства, с которого была выполнена загрузка. В случае загрузки с host'а в этом поле будет NULL. В дальнейшем поля структуры bootsource можно использовать в виде API для считывания дополнительных данных с устройства, откуда была произведена загрузка.

## Расчет контрольной суммы

Используется релизация CRC-32-IEEE 802.3 с полиномом X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0

Реализация доступна, например, из языка python (версия 3)
```python

import binascii
crc32 = binascii.crc32(data)
```
Для подготовки образов расчета контрольных сумм предлагается готовая утилита на языке python (rumboot-packimage.py)

## Процедура формирования образов вторичного загрузчика

Образ вторичного загрузчика формируется в четыре стадии

- На этапе компиляции заголовок образа определяется со всеми полями, кроме контрльных сумм и помещается в виде структуры в отдельную секцию.

Пример bootheader.c, который должен быть частью проекта вторичного загрузчика.

```c
#include <stdint.h>
#include <rumboot/boot.h>
#include <rumboot/platform.h>

extern void rumboot_main();
extern int main();

static const __attribute__((used)) __attribute__((section(".header")))
struct rumboot_bootheader hdr = {
    .magic        = RUMBOOT_HEADER_MAGIC,
    .version    = RUMBOOT_HEADER_VERSION,
    .chip_id    = RUMBOOT_PLATFORM_CHIPID,
    .chip_rev    = RUMBOOT_PLATFORM_CHIPREV,
    .entry_point    = {
        (uint32_t)&main,
    }
};
```

- На этапе компоновки сценарий компановщика размещает секцию с заголовком в самом начале файла. Пример минимального ld сценария приведен ниже.

```lds
OUTPUT_ARCH(ARM)
MEMORY
{
    IM0 (rwx): ORIGIN = 0x40000, LENGTH = 0x40000
}

SECTIONS
{

 .header : {
   KEEP(*(.header))
 } > IM0

 .rwx : {
  *(.text)
  *(.text.*)
  *(.rodata)
  *(.data)
  } > IM0

}
```

- После компановки из полученного файла в формате elf стандартными средствами компилятора генерируется .bin файл. Например:

```
arm-rcm-eabihf-objcopy --gap-fill 0x00 -O binary hello_world hello_world.bin
```

- После вышеуказанных действий утилита rumboot-packimage.py производит расчет и запись контрольных сумм в заголовок образа. Пример работы данной утилиты приведен ниже.

```
rumboot_packimage.py -f rumboot-basis-Debug-spl.bin -c
Wrote valid checksums to image header
=== RumBootV2 Header Information ===
Endianess:              little
Magic:                  0xb01dface
Header Version:         0x2
Chip ID:                0x3
Chip Revision:          0x1
Data Length:            380
Header CRC32:           0x7e2fc690 [Valid]
Data CRC32:             0x7824b25a [Valid]
```

## Использование указателя bootsrc для чтения дополнительных данных с загрузочного устройства из вторичного загрузчика

TODO: Примеры кода

## Получение служебной информации о версии RumBoot, СhipId/ChipRevision из вторичного загрузчика

TODO: Примеры кода

## Получение результатов процедуры самотестирования из вторичного загрузчика

TODO: Примеры кода

## Последовательное исполнение кода из нескольких источников

RumBoot поддерживает последовательное исполнение кода из нескольких источников, в случае если после исполнения кода вторичного загрузчика был произведен возврат в код ROM с кодом завершения.

Точка входа в образ вторичного загрузчика имеет следующий формат.

```
int main();
```

Переход на точку входа выполняется как вызов функции, а не безусловный переход. После вызова загрузчиком и исполения этой функции, дальнейшее поведение зависит от возвращаемого этой функцией значения.

- \>= 0 - Принудительная загрузка с источника номер N (Если N больше количества доступных источников - переход в хост-режим)

- -1 - продолжить цепочку загрузки

- <-1 - принудительный переход в хост-режим

## Хост-режим загрузки

Хост-режим - это специальный режим загрузки, который предназначен для обновления ПО.

В этом режиме загружаемый образ вторичного загрузчика может
быть размещен в накристальной памяти используя пассивный или активный метод.

К пассивным относится загрузка по интерфейсам JTAG, EDCL или Spacewire RMAP (если присутствуют). Загрузка по этим интерфейсам не требует конфигурации и загрузчик просто опрашивает периодически соответствующую область памяти.

К активному режиму относится загрузка по протоколу xmodem поверх UART или любому другому, который требует соответствующей реализации в составе bootrom.

Плагины, обеспечивающие загрузку в активном режиме можно выбирать на этапе компиляции загрузчика.

Плагин                  | Проект      | Статус
----------------------- | ----------- | -----------------
xmodem (UART)           | basis, oi10 | планируется
Командная строка (UART) | basis, oi10 | планируется
GDB RSP                 | ?           | Если успеем

В host режиме, при успешной загрузке поле bootsrc устанавливается в NULL.

В случае ошибки при валидации загружаемого образа загрузчик выводит диагностическое сообщение в UART, а так же переписывает поле magic кодом ошибки. Список возможных ошибок приведен ниже.

```
#define EBADMAGIC      1
#define EBADVERSION    2
#define EBADHDRCRC     3
#define EBADCHIPID     4
#define EBADENTRY      5
#define EBADDATACRC    6
#define EMAXERROR      7
```

При загрузке по интерфейсу edcl/rmap/jtag для избежания преждевременной попытки валидации образа рекомендуется:

- Загрузить данные, начиная с 4го байта и до конца образа
- Установить magic (первые 4 байта) в валидное значение


### Интерфейс командной строки

Интерфейс командной строки доступен в хост режиме и позволяет:

- Вызывать индивидуальные компоненты процедуры самотестирования

- Выполнить загрузку с указанного устройства

- Вывести информацию о версии загрузчика

- Вызвать загрузку и исполнения файла по протоколу xmodem

- Писать/читать память

Можно расширять интерфейс командной строки дополнительными командами, по мере
необходимости.

# Приложение А: Таблица идентификаторов ChipID

ОКР   | Part Number | Endianess | #Cores | ChipID | ChipRev
----- | ----------- | --------- | ------ | ------ | -------
7705* | ???         | big       | 2      | 1      | 1
7705* | 1888ТХ018   | big       | 2      | 2      | 2
Базис | ???         | little    | 1      | 3      | 1
ОИ-10 | ???         | big       | 1      | 4      | 1

* Используют другой формат образа. Указанные ChipID/ChipRev используются только для прототипирования.


# Приложение В: Старые форматы образов загрузчика

TBD
